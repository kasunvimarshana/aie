var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { autoinject } from 'aurelia-dependency-injection';
import { SessionService } from './session';
var Permission = (function () {
    function Permission(type, state) {
        this.type = type;
        this.state = state || PermissionState.NOT_REQUIRED;
    }
    return Permission;
}());
export { Permission };
export var PermissionState;
(function (PermissionState) {
    PermissionState[PermissionState["NOT_REQUIRED"] = 'not_required'] = "NOT_REQUIRED";
    PermissionState[PermissionState["PROMPT"] = 'prompt'] = "PROMPT";
    PermissionState[PermissionState["GRANTED"] = 'granted'] = "GRANTED";
    PermissionState[PermissionState["DENIED"] = 'denied'] = "DENIED";
})(PermissionState || (PermissionState = {}));
/**
 * Access permission states
 */
var PermissionService = (function () {
    function PermissionService(sessionService) {
        this.sessionService = sessionService;
    }
    /**
     * Query current state of permission
     *
     * @returns A Promise that resolves to the current state of the permission
     */
    // public query() : Promise<Permission[]>;
    PermissionService.prototype.query = function (type, session) {
        if (session === void 0) { session = this.sessionService.manager; }
        // let permissionMaps: Permission[] = [];
        return session.request('ar.permission.query', { type: type }).then(function (_a) {
            var state = _a.state;
            return state || PermissionState.NOT_REQUIRED;
        });
    };
    /**
     * Revoke permissions
     *
     * @returns A promise that resolves to the state of requested permission after revoking.
     * Should be PermissionState.Denied on success.
     */
    PermissionService.prototype.revoke = function (type) {
        var session = this.sessionService.manager;
        return session.request('ar.permission.revoke', { type: type }).then(function (_a) {
            var state = _a.state;
            return state;
        });
    };
    PermissionService = __decorate([
        autoinject(),
        __metadata("design:paramtypes", [SessionService])
    ], PermissionService);
    return PermissionService;
}());
export { PermissionService };
/**
 * Manage permissions
 */
var PermissionServiceProvider = (function () {
    function PermissionServiceProvider(sessionService) {
        var _this = this;
        this.sessionService = sessionService;
        this.sessionService.ensureIsRealityManager();
        this.sessionService.connectEvent.addEventListener(function (session) {
            session.on['ar.permission.query'] = function (_a) {
                var type = _a.type;
                return Promise.resolve({ state: _this.getPermissionState(session, type) });
            };
            /**
             * Browswer should override this if they want to allow revoking permissions.
             * @param type
             * @returns A promise that resolves to the state of the permission after revoking
             */
            session.on['ar.permission.revoke'] = function (_a) {
                var type = _a.type;
                return Promise.reject(new Error("Revoking permission is not supported on this browser."));
            };
        });
    }
    /**
     * Browsers should override this and ask the users via their own UI.
     * The permissions should be stored locally based on the host name and id(=type).
     * @param session Used to acquire hostname from the uri.
     * @param id Can be used as a type of permission. Also can be random id's on Vuforia requests.
     * @returns A resolved promise if subscription is permitted.
     * @returns A rejected promise if subscription is not permitted.
     */
    PermissionServiceProvider.prototype.handlePermissionRequest = function (session, id, options) {
        return Promise.resolve();
    };
    /**
     * Browsers should override this to check their locally stored permissions.
     * @param type
     * @returns The current state of the permission
     */
    PermissionServiceProvider.prototype.getPermissionState = function (session, type) {
        return PermissionState.GRANTED;
    };
    PermissionServiceProvider = __decorate([
        autoinject(),
        __metadata("design:paramtypes", [SessionService])
    ], PermissionServiceProvider);
    return PermissionServiceProvider;
}());
export { PermissionServiceProvider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBlcm1pc3Npb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzFELE9BQU8sRUFBRSxjQUFjLEVBQWUsTUFBTSxXQUFXLENBQUM7QUFPeEQ7SUFJSSxvQkFBWSxJQUFvQixFQUFFLEtBQXVCO1FBQ3JELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJLGVBQWUsQ0FBQyxZQUFZLENBQUM7SUFDdkQsQ0FBQztJQUNMLGlCQUFDO0FBQUQsQ0FBQyxBQVJELElBUUM7O0FBRUQsTUFBTSxDQUFOLElBQVksZUFLWDtBQUxELFdBQVksZUFBZTtJQUN2QixrREFBZSxjQUFxQixrQkFBQSxDQUFBO0lBQ3BDLDRDQUFTLFFBQWUsWUFBQSxDQUFBO0lBQ3hCLDZDQUFVLFNBQWdCLGFBQUEsQ0FBQTtJQUMxQiw0Q0FBUyxRQUFlLFlBQUEsQ0FBQTtBQUM1QixDQUFDLEVBTFcsZUFBZSxLQUFmLGVBQWUsUUFLMUI7QUFFRDs7R0FFRztBQUVIO0lBQ0ksMkJBQXNCLGNBQThCO1FBQTlCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtJQUVwRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDBDQUEwQztJQUNuQyxpQ0FBSyxHQUFaLFVBQWEsSUFBb0IsRUFBRSxPQUFxQztRQUFyQyx3QkFBQSxFQUFBLFVBQVUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPO1FBQ3BFLHlDQUF5QztRQUN6QyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBMkIscUJBQXFCLEVBQUUsRUFBQyxJQUFJLE1BQUEsRUFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsRUFBTztnQkFBTixnQkFBSztZQUN4RixNQUFNLENBQUMsS0FBSyxJQUFJLGVBQWUsQ0FBQyxZQUFZLENBQUM7UUFDakQsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxrQ0FBTSxHQUFiLFVBQWMsSUFBb0I7UUFDOUIsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUM7UUFDNUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQTJCLHNCQUFzQixFQUFFLEVBQUMsSUFBSSxNQUFBLEVBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLEVBQU87Z0JBQU4sZ0JBQUs7WUFDekYsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUE3QlEsaUJBQWlCO1FBRDdCLFVBQVUsRUFBRTt5Q0FFNkIsY0FBYztPQUQzQyxpQkFBaUIsQ0ErQjdCO0lBQUQsd0JBQUM7Q0FBQSxBQS9CRCxJQStCQztTQS9CWSxpQkFBaUI7QUFpQzlCOztHQUVHO0FBRUg7SUFFSSxtQ0FBb0IsY0FBNkI7UUFBakQsaUJBaUJDO1FBakJtQixtQkFBYyxHQUFkLGNBQWMsQ0FBZTtRQUM3QyxJQUFJLENBQUMsY0FBYyxDQUFDLHNCQUFzQixFQUFFLENBQUM7UUFDN0MsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsVUFBQyxPQUFvQjtZQUVuRSxPQUFPLENBQUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsVUFBQyxFQUE4QjtvQkFBN0IsY0FBSTtnQkFDdEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBQyxLQUFLLEVBQUUsS0FBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUM7WUFDNUUsQ0FBQyxDQUFBO1lBRUQ7Ozs7ZUFJRztZQUNILE9BQU8sQ0FBQyxFQUFFLENBQUMsc0JBQXNCLENBQUMsR0FBRyxVQUFDLEVBQThCO29CQUE3QixjQUFJO2dCQUN2QyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDLENBQUM7WUFDOUYsQ0FBQyxDQUFBO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLDJEQUF1QixHQUE5QixVQUErQixPQUFvQixFQUFFLEVBQVUsRUFBRSxPQUFZO1FBQ3pFLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxzREFBa0IsR0FBekIsVUFBMEIsT0FBb0IsRUFBRSxJQUFvQjtRQUNoRSxNQUFNLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQztJQUNuQyxDQUFDO0lBeENRLHlCQUF5QjtRQURyQyxVQUFVLEVBQUU7eUNBRzBCLGNBQWM7T0FGeEMseUJBQXlCLENBeUNyQztJQUFELGdDQUFDO0NBQUEsQUF6Q0QsSUF5Q0M7U0F6Q1kseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXV0b2luamVjdCB9IGZyb20gJ2F1cmVsaWEtZGVwZW5kZW5jeS1pbmplY3Rpb24nO1xuaW1wb3J0IHsgU2Vzc2lvblNlcnZpY2UsIFNlc3Npb25Qb3J0IH0gZnJvbSAnLi9zZXNzaW9uJztcblxuZXhwb3J0IHR5cGUgUGVybWlzc2lvblR5cGUgPSBcbiAgICAnZ2VvbG9jYXRpb24nICAgICAgICAgIC8vR2VvbG9jYXRpb25cbiAgICB8ICdjYW1lcmEnICAgICAgICAgIC8vQ2FtZXJhXG4gICAgfCAnd29ybGQtc3RydWN0dXJlJzsgICAgICAvLzNEIFN0cnVjdHVyYWwgbWVzaFxuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbiB7XG4gICAgcmVhZG9ubHkgdHlwZTogUGVybWlzc2lvblR5cGU7XG4gICAgcmVhZG9ubHkgc3RhdGU6IFBlcm1pc3Npb25TdGF0ZTtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGU6IFBlcm1pc3Npb25UeXBlLCBzdGF0ZT86IFBlcm1pc3Npb25TdGF0ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgUGVybWlzc2lvblN0YXRlLk5PVF9SRVFVSVJFRDtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIFBlcm1pc3Npb25TdGF0ZSB7XG4gICAgTk9UX1JFUVVJUkVEID0gJ25vdF9yZXF1aXJlZCcgYXMgYW55LCAgIC8vRGVmYXVsdCBzdGF0ZS4gUGVybWlzc2lvbiBpcyBub3QgYmVpbmcgdXNlZC5cbiAgICBQUk9NUFQgPSAncHJvbXB0JyBhcyBhbnksICAgICAgICAgLy9QZXJtaXNzaW9uIHNob3VsZCBiZSBhc2tlZCBmb3IgZnJvbSB0aGUgdXNlci5cbiAgICBHUkFOVEVEID0gJ2dyYW50ZWQnIGFzIGFueSwgICAgICAgLy9QZXJtaXNzaW9uIGhhcyBiZWVuIGdyYW50ZWQuXG4gICAgREVOSUVEID0gJ2RlbmllZCcgYXMgYW55LCAgICAgICAgLy9QZXJtaXNzaW9uIGhhcyBiZWVuIGRlbmllZC5cbn1cblxuLyoqXG4gKiBBY2Nlc3MgcGVybWlzc2lvbiBzdGF0ZXNcbiAqL1xuQGF1dG9pbmplY3QoKVxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgc2Vzc2lvblNlcnZpY2U6IFNlc3Npb25TZXJ2aWNlKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjdXJyZW50IHN0YXRlIG9mIHBlcm1pc3Npb25cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcGVybWlzc2lvblxuICAgICAqL1xuICAgIC8vIHB1YmxpYyBxdWVyeSgpIDogUHJvbWlzZTxQZXJtaXNzaW9uW10+O1xuICAgIHB1YmxpYyBxdWVyeSh0eXBlOiBQZXJtaXNzaW9uVHlwZSwgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvblNlcnZpY2UubWFuYWdlcikgOiBQcm9taXNlPFBlcm1pc3Npb25TdGF0ZT4ge1xuICAgICAgICAvLyBsZXQgcGVybWlzc2lvbk1hcHM6IFBlcm1pc3Npb25bXSA9IFtdO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbi5yZXF1ZXN0PHtzdGF0ZTogUGVybWlzc2lvblN0YXRlfT4oJ2FyLnBlcm1pc3Npb24ucXVlcnknLCB7dHlwZX0pLnRoZW4oKHtzdGF0ZX0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8fCBQZXJtaXNzaW9uU3RhdGUuTk9UX1JFUVVJUkVEO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZva2UgcGVybWlzc2lvbnNcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUgb2YgcmVxdWVzdGVkIHBlcm1pc3Npb24gYWZ0ZXIgcmV2b2tpbmcuXG4gICAgICogU2hvdWxkIGJlIFBlcm1pc3Npb25TdGF0ZS5EZW5pZWQgb24gc3VjY2Vzcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmV2b2tlKHR5cGU6IFBlcm1pc3Npb25UeXBlKSA6IFByb21pc2U8UGVybWlzc2lvblN0YXRlPiB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLnNlc3Npb25TZXJ2aWNlLm1hbmFnZXI7XG4gICAgICAgIHJldHVybiBzZXNzaW9uLnJlcXVlc3Q8e3N0YXRlOiBQZXJtaXNzaW9uU3RhdGV9PignYXIucGVybWlzc2lvbi5yZXZva2UnLCB7dHlwZX0pLnRoZW4oKHtzdGF0ZX0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogTWFuYWdlIHBlcm1pc3Npb25zXG4gKi9cbkBhdXRvaW5qZWN0KClcbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uU2VydmljZVByb3ZpZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc2Vzc2lvblNlcnZpY2U6U2Vzc2lvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uU2VydmljZS5lbnN1cmVJc1JlYWxpdHlNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblNlcnZpY2UuY29ubmVjdEV2ZW50LmFkZEV2ZW50TGlzdGVuZXIoKHNlc3Npb246IFNlc3Npb25Qb3J0KSA9PiB7XG5cbiAgICAgICAgICAgIHNlc3Npb24ub25bJ2FyLnBlcm1pc3Npb24ucXVlcnknXSA9ICh7dHlwZX06IHt0eXBlOiBQZXJtaXNzaW9uVHlwZX0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0ZTogdGhpcy5nZXRQZXJtaXNzaW9uU3RhdGUoc2Vzc2lvbiwgdHlwZSl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCcm93c3dlciBzaG91bGQgb3ZlcnJpZGUgdGhpcyBpZiB0aGV5IHdhbnQgdG8gYWxsb3cgcmV2b2tpbmcgcGVybWlzc2lvbnMuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAgICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlIG9mIHRoZSBwZXJtaXNzaW9uIGFmdGVyIHJldm9raW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlc3Npb24ub25bJ2FyLnBlcm1pc3Npb24ucmV2b2tlJ10gPSAoe3R5cGV9OiB7dHlwZTogUGVybWlzc2lvblR5cGV9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJldm9raW5nIHBlcm1pc3Npb24gaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnJvd3NlcnMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgYW5kIGFzayB0aGUgdXNlcnMgdmlhIHRoZWlyIG93biBVSS5cbiAgICAgKiBUaGUgcGVybWlzc2lvbnMgc2hvdWxkIGJlIHN0b3JlZCBsb2NhbGx5IGJhc2VkIG9uIHRoZSBob3N0IG5hbWUgYW5kIGlkKD10eXBlKS5cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBVc2VkIHRvIGFjcXVpcmUgaG9zdG5hbWUgZnJvbSB0aGUgdXJpLlxuICAgICAqIEBwYXJhbSBpZCBDYW4gYmUgdXNlZCBhcyBhIHR5cGUgb2YgcGVybWlzc2lvbi4gQWxzbyBjYW4gYmUgcmFuZG9tIGlkJ3Mgb24gVnVmb3JpYSByZXF1ZXN0cy5cbiAgICAgKiBAcmV0dXJucyBBIHJlc29sdmVkIHByb21pc2UgaWYgc3Vic2NyaXB0aW9uIGlzIHBlcm1pdHRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHJlamVjdGVkIHByb21pc2UgaWYgc3Vic2NyaXB0aW9uIGlzIG5vdCBwZXJtaXR0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZVBlcm1pc3Npb25SZXF1ZXN0KHNlc3Npb246IFNlc3Npb25Qb3J0LCBpZDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJyb3dzZXJzIHNob3VsZCBvdmVycmlkZSB0aGlzIHRvIGNoZWNrIHRoZWlyIGxvY2FsbHkgc3RvcmVkIHBlcm1pc3Npb25zLlxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBlcm1pc3Npb25cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UGVybWlzc2lvblN0YXRlKHNlc3Npb246IFNlc3Npb25Qb3J0LCB0eXBlOiBQZXJtaXNzaW9uVHlwZSl7XG4gICAgICAgIHJldHVybiBQZXJtaXNzaW9uU3RhdGUuR1JBTlRFRDtcbiAgICB9XG59Il19