// @author: YousefED
// From https://github.com/YousefED/cesium/commit/3791582640b12753c7ebd09efe4d7a032fcbfeca
import { Credit, defaultValue, defined, Ellipsoid, Event, WebMercatorTilingScheme, getImagePixels, HeightmapTerrainData, loadImage, TerrainProvider } from './cesium-imports';
/**
 * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
 * retrieved from Mapzen (which are publicly hosted on S3).
 *
 * @alias MapzenTerrariumTerrainProvider
 * @constructor
 *
 * @param {Object} options Object with the following properties:
 * @param {String} options.url The base url, e.g.: https://s3.amazonaws.com/elevation-tiles-prod/terrarium/ .
 * @param {Object} [options.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
 * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the terrain
 *                       is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
 *                       is used.
 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
 *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.
 *                    If neither parameter is specified, the WGS84 ellipsoid is used.
 * @param {Credit|String} [options.credit] The credit, which will is displayed on the canvas.
 *
 *
 * @example
 * var terrainProvider = new Cesium.MapzenTerrariumTerrainProvider({
 *   url : 'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/',
 * });
 * viewer.terrainProvider = terrainProvider;
 *
 *  @see TerrainProvider
 */
export function MapzenTerrariumTerrainProvider(options) {
    //>>includeStart('debug', pragmas.debug);
    this._token = options.token;
    this._url = options.url;
    this._tilingScheme = options.tilingScheme;
    if (!defined(this._tilingScheme)) {
        /*this._tilingScheme = new GeographicTilingScheme({
            ellipsoid : defaultValue(options.ellipsoid, Ellipsoid.WGS84)
        });*/
        this._tilingScheme = new WebMercatorTilingScheme({
            numberOfLevelZeroTilesX: 1,
            numberOfLevelZeroTilesY: 1,
            ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84)
        });
    }
    this._heightmapWidth = 64;
    this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0));
    this._proxy = options.proxy;
    this._terrainDataStructure = {
        heightScale: 1.0 / 256.0,
        heightOffset: -32768.0,
        elementsPerHeight: 3,
        stride: 4,
        elementMultiplier: 256.0,
        isBigEndian: true,
        lowestEncodedHeight: 0,
        highestEncodedHeight: 256 * 256 * 256 - 1
    };
    this._errorEvent = new Event();
    var credit = options.credit;
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
    this._readyPromise = Promise.resolve(true);
    this._terrainPromises = {};
}
Object.defineProperties(MapzenTerrariumTerrainProvider.prototype, {
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     * @memberof ArcGisImageServerTerrainProvider.prototype
     * @type {Event}
     */
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.  This function should not be called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
     * @memberof MapzenTerrariumTerrainProvider.prototype
     * @type {Credit}
     */
    credit: {
        get: function () {
            return this._credit;
        }
    },
    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
     * @memberof MapzenTerrariumTerrainProvider.prototype
     * @type {GeographicTilingScheme}
     */
    tilingScheme: {
        get: function () {
            return this._tilingScheme;
        }
    },
    /**
     * Gets a value indicating whether or not the provider is ready for use.
     * @memberof MapzenTerrariumTerrainProvider.prototype
     * @type {Boolean}
     */
    ready: {
        get: function () {
            return true;
        }
    },
    /**
     * Gets a promise that resolves to true when the provider is ready for use.
     * @memberof MapzenTerrariumTerrainProvider.prototype
     * @type {Promise.<Boolean>}
     * @readonly
     */
    readyPromise: {
        get: function () {
            return this._readyPromise;
        }
    },
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.  This function should not be
     * called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
     * @memberof MapzenTerrariumTerrainProvider.prototype
     * @type {Boolean}
     */
    hasWaterMask: {
        get: function () {
            return false;
        }
    },
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     * This function should not be called before {@link MapzenTerrariumTerrainProvider#ready} returns true.
     * @memberof MapzenTerrariumTerrainProvider.prototype
     * @type {Boolean}
     */
    hasVertexNormals: {
        get: function () {
            return false;
        }
    }
});
/**
 * Requests the geometry for a given tile.  This function should not be called before
 * {@link MapzenTerrariumTerrainProvider#ready} returns true.  The result includes terrain
 * data and indicates that all child tiles are available.
 *
 * @param {Number} x The X coordinate of the tile for which to request geometry.
 * @param {Number} y The Y coordinate of the tile for which to request geometry.
 * @param {Number} level The level of the tile for which to request geometry.
 * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
 *          returns undefined instead of a promise, it is an indication that too many requests are already
 *          pending and the request will be retried later.
 */
MapzenTerrariumTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {
    var url = this._url + level + '/' + x + '/' + y + '.png';
    var proxy = this._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    var promise = this._terrainPromises[url];
    if (!promise) {
        promise = loadImage(url, true, request);
        this._terrainPromises[url] = promise;
    }
    var that = this;
    return promise.then(function (image) {
        return new HeightmapTerrainData({
            buffer: getImagePixels(image, that._heightmapWidth, that._heightmapWidth),
            width: that._heightmapWidth,
            height: that._heightmapWidth,
            childTileMask: level < 16 ? 0 : 15,
            structure: that._terrainDataStructure
        });
    });
};
/**
 * Gets the maximum geometric error allowed in a tile at a given level.
 *
 * @param {Number} level The tile level for which to get the maximum geometric error.
 * @returns {Number} The maximum geometric error.
 */
MapzenTerrariumTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {
    return this._levelZeroMaximumGeometricError / (1 << level);
};
/**
 * Determines whether data for a tile is available to be loaded.
 *
 * @param {Number} x The X coordinate of the tile for which to request geometry.
 * @param {Number} y The Y coordinate of the tile for which to request geometry.
 * @param {Number} level The level of the tile for which to request geometry.
 * @returns {Boolean} Undefined if not supported, otherwise true or false.
 */
MapzenTerrariumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {
    return level < 16 ? true : undefined;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQjtBQUNwQiwwRkFBMEY7QUFFMUYsT0FBTyxFQUNILE1BQU0sRUFDTixZQUFZLEVBQ1osT0FBTyxFQUNQLFNBQVMsRUFDVCxLQUFLLEVBQ0wsdUJBQXVCLEVBQ3ZCLGNBQWMsRUFDZCxvQkFBb0IsRUFDcEIsU0FBUyxFQUNULGVBQWUsRUFDbEIsTUFBTSxrQkFBa0IsQ0FBQTtBQUd6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQkc7QUFDSCxNQUFNLHlDQUF5QyxPQUFPO0lBQ2xELHlDQUF5QztJQUV6QyxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDNUIsSUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztJQUMxQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9COzthQUVLO1FBQ0wsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLHVCQUF1QixDQUFDO1lBQzdDLHVCQUF1QixFQUFDLENBQUM7WUFDekIsdUJBQXVCLEVBQUMsQ0FBQztZQUN6QixTQUFTLEVBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQztTQUMvRCxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7SUFDMUIsSUFBSSxDQUFDLCtCQUErQixHQUFHLGVBQWUsQ0FBQyxnREFBZ0QsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRSxJQUFJ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ZXNDb250ZW50IjpbIi8vIEBhdXRob3I6IFlvdXNlZkVEXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9Zb3VzZWZFRC9jZXNpdW0vY29tbWl0LzM3OTE1ODI2NDBiMTI3NTNjN2ViZDA5ZWZlNGQ3YTAzMmZjYmZlY2FcblxuaW1wb3J0IHsgICAgICAgICBcbiAgICBDcmVkaXQsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIGRlZmluZWQsXG4gICAgRWxsaXBzb2lkLFxuICAgIEV2ZW50LFxuICAgIFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lLFxuICAgIGdldEltYWdlUGl4ZWxzLFxuICAgIEhlaWdodG1hcFRlcnJhaW5EYXRhLFxuICAgIGxvYWRJbWFnZSxcbiAgICBUZXJyYWluUHJvdmlkZXJcbn0gZnJvbSAnLi9jZXNpdW0taW1wb3J0cydcblxuXG4vKipcbiAqIEEge0BsaW5rIFRlcnJhaW5Qcm92aWRlcn0gdGhhdCBwcm9kdWNlcyB0ZXJyYWluIGdlb21ldHJ5IGJ5IHRlc3NlbGxhdGluZyBoZWlnaHQgbWFwc1xuICogcmV0cmlldmVkIGZyb20gTWFwemVuICh3aGljaCBhcmUgcHVibGljbHkgaG9zdGVkIG9uIFMzKS5cbiAqXG4gKiBAYWxpYXMgTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgVGhlIGJhc2UgdXJsLCBlLmcuOiBodHRwczovL3MzLmFtYXpvbmF3cy5jb20vZWxldmF0aW9uLXRpbGVzLXByb2QvdGVycmFyaXVtLyAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJveHldIEEgcHJveHkgdG8gdXNlIGZvciByZXF1ZXN0cy4gVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGdldFVSTCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBwcm94aWVkIFVSTCwgaWYgbmVlZGVkLlxuICogQHBhcmFtIHtUaWxpbmdTY2hlbWV9IFtvcHRpb25zLnRpbGluZ1NjaGVtZV0gVGhlIHRpbGluZyBzY2hlbWUgc3BlY2lmeWluZyBob3cgdGhlIHRlcnJhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICBpcyBicm9rZW4gaW50byB0aWxlcy4gIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCwgYSB7QGxpbmsgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZX1cbiAqICAgICAgICAgICAgICAgICAgICAgICBpcyB1c2VkLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZF0gVGhlIGVsbGlwc29pZC4gIElmIHRoZSB0aWxpbmdTY2hlbWUgaXMgc3BlY2lmaWVkLFxuICogICAgICAgICAgICAgICAgICAgIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQgYW5kIHRoZSB0aWxpbmcgc2NoZW1lJ3MgZWxsaXBzb2lkIGlzIHVzZWQgaW5zdGVhZC5cbiAqICAgICAgICAgICAgICAgICAgICBJZiBuZWl0aGVyIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQsIHRoZSBXR1M4NCBlbGxpcHNvaWQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Q3JlZGl0fFN0cmluZ30gW29wdGlvbnMuY3JlZGl0XSBUaGUgY3JlZGl0LCB3aGljaCB3aWxsIGlzIGRpc3BsYXllZCBvbiB0aGUgY2FudmFzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHRlcnJhaW5Qcm92aWRlciA9IG5ldyBDZXNpdW0uTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyKHtcbiAqICAgdXJsIDogJ2h0dHBzOi8vczMuYW1hem9uYXdzLmNvbS9lbGV2YXRpb24tdGlsZXMtcHJvZC90ZXJyYXJpdW0vJyxcbiAqIH0pO1xuICogdmlld2VyLnRlcnJhaW5Qcm92aWRlciA9IHRlcnJhaW5Qcm92aWRlcjtcbiAqXG4gKiAgQHNlZSBUZXJyYWluUHJvdmlkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1hcHplblRlcnJhcml1bVRlcnJhaW5Qcm92aWRlcihvcHRpb25zKSB7XG4gICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICBcbiAgICB0aGlzLl90b2tlbiA9IG9wdGlvbnMudG9rZW47XG4gICAgdGhpcy5fdXJsID0gb3B0aW9ucy51cmw7XG4gICAgdGhpcy5fdGlsaW5nU2NoZW1lID0gb3B0aW9ucy50aWxpbmdTY2hlbWU7XG4gICAgaWYgKCFkZWZpbmVkKHRoaXMuX3RpbGluZ1NjaGVtZSkpIHtcbiAgICAgICAgLyp0aGlzLl90aWxpbmdTY2hlbWUgPSBuZXcgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZSh7XG4gICAgICAgICAgICBlbGxpcHNvaWQgOiBkZWZhdWx0VmFsdWUob3B0aW9ucy5lbGxpcHNvaWQsIEVsbGlwc29pZC5XR1M4NClcbiAgICAgICAgfSk7Ki8gXG4gICAgICAgIHRoaXMuX3RpbGluZ1NjaGVtZSA9IG5ldyBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZSh7XG4gICAgICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWDoxLFxuICAgICAgICAgICAgbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1k6MSxcbiAgICAgICAgICAgIGVsbGlwc29pZCA6IGRlZmF1bHRWYWx1ZShvcHRpb25zLmVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWlnaHRtYXBXaWR0aCA9IDY0O1xuICAgIHRoaXMuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciA9IFRlcnJhaW5Qcm92aWRlci5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAodGhpcy5fdGlsaW5nU2NoZW1lLmVsbGlwc29pZCwgdGhpcy5faGVpZ2h0bWFwV2lkdGgsIHRoaXMuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoMCkpO1xuXG4gICAgdGhpcy5fcHJveHkgPSBvcHRpb25zLnByb3h5O1xuXG4gICAgdGhpcy5fdGVycmFpbkRhdGFTdHJ1Y3R1cmUgPSB7XG4gICAgICAgIGhlaWdodFNjYWxlIDogMS4wIC8gMjU2LjAsXG4gICAgICAgIGhlaWdodE9mZnNldCA6IC0zMjc2OC4wLFxuICAgICAgICBlbGVtZW50c1BlckhlaWdodCA6IDMsXG4gICAgICAgIHN0cmlkZSA6IDQsXG4gICAgICAgIGVsZW1lbnRNdWx0aXBsaWVyIDogMjU2LjAsXG4gICAgICAgIGlzQmlnRW5kaWFuIDogdHJ1ZSxcbiAgICAgICAgbG93ZXN0RW5jb2RlZEhlaWdodCA6IDAsXG4gICAgICAgIGhpZ2hlc3RFbmNvZGVkSGVpZ2h0IDogMjU2ICogMjU2ICogMjU2IC0gMVxuICAgIH07XG5cbiAgICB0aGlzLl9lcnJvckV2ZW50ID0gbmV3IEV2ZW50KCk7XG5cbiAgICB2YXIgY3JlZGl0ID0gb3B0aW9ucy5jcmVkaXQ7XG4gICAgaWYgKHR5cGVvZiBjcmVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNyZWRpdCA9IG5ldyBDcmVkaXQoY3JlZGl0KTtcbiAgICB9XG4gICAgdGhpcy5fY3JlZGl0ID0gY3JlZGl0O1xuICAgIHRoaXMuX3JlYWR5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblxuICAgIHRoaXMuX3RlcnJhaW5Qcm9taXNlcyA9IHt9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNYXB6ZW5UZXJyYXJpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBldmVudCB0aGF0IGlzIHJhaXNlZCB3aGVuIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGVuY291bnRlcnMgYW4gYXN5bmNocm9ub3VzIGVycm9yLiAgQnkgc3Vic2NyaWJpbmdcbiAgICAgKiB0byB0aGUgZXZlbnQsIHlvdSB3aWxsIGJlIG5vdGlmaWVkIG9mIHRoZSBlcnJvciBhbmQgY2FuIHBvdGVudGlhbGx5IHJlY292ZXIgZnJvbSBpdC4gIEV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFyZSBwYXNzZWQgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFRpbGVQcm92aWRlckVycm9yfS5cbiAgICAgKiBAbWVtYmVyb2YgQXJjR2lzSW1hZ2VTZXJ2ZXJUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge0V2ZW50fVxuICAgICAqL1xuICAgIGVycm9yRXZlbnQgOiB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3JlZGl0IHRvIGRpc3BsYXkgd2hlbiB0aGlzIHRlcnJhaW4gcHJvdmlkZXIgaXMgYWN0aXZlLiAgVHlwaWNhbGx5IHRoaXMgaXMgdXNlZCB0byBjcmVkaXRcbiAgICAgKiB0aGUgc291cmNlIG9mIHRoZSB0ZXJyYWluLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIE1hcHplblRlcnJhcml1bVRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgICAqIEBtZW1iZXJvZiBNYXB6ZW5UZXJyYXJpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge0NyZWRpdH1cbiAgICAgKi9cbiAgICBjcmVkaXQgOiB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWRpdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aWxpbmcgc2NoZW1lIHVzZWQgYnkgdGhpcyBwcm92aWRlci4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkXG4gICAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIE1hcHplblRlcnJhcml1bVRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgICAqIEBtZW1iZXJvZiBNYXB6ZW5UZXJyYXJpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge0dlb2dyYXBoaWNUaWxpbmdTY2hlbWV9XG4gICAgICovXG4gICAgdGlsaW5nU2NoZW1lIDoge1xuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWxpbmdTY2hlbWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVyIGlzIHJlYWR5IGZvciB1c2UuXG4gICAgICogQG1lbWJlcm9mIE1hcHplblRlcnJhcml1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICByZWFkeSA6IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgd2hlbiB0aGUgcHJvdmlkZXIgaXMgcmVhZHkgZm9yIHVzZS5cbiAgICAgKiBAbWVtYmVyb2YgTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtQcm9taXNlLjxCb29sZWFuPn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICByZWFkeVByb21pc2UgOiB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZXIgaW5jbHVkZXMgYSB3YXRlciBtYXNrLiAgVGhlIHdhdGVyIG1hc2tcbiAgICAgKiBpbmRpY2F0ZXMgd2hpY2ggYXJlYXMgb2YgdGhlIGdsb2JlIGFyZSB3YXRlciByYXRoZXIgdGhhbiBsYW5kLCBzbyB0aGV5IGNhbiBiZSByZW5kZXJlZFxuICAgICAqIGFzIGEgcmVmbGVjdGl2ZSBzdXJmYWNlIHdpdGggYW5pbWF0ZWQgd2F2ZXMuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmVcbiAgICAgKiBjYWxsZWQgYmVmb3JlIHtAbGluayBNYXB6ZW5UZXJyYXJpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAbWVtYmVyb2YgTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1dhdGVyTWFzayA6IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHJlcXVlc3RlZCB0aWxlcyBpbmNsdWRlIHZlcnRleCBub3JtYWxzLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBNYXB6ZW5UZXJyYXJpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAbWVtYmVyb2YgTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1ZlcnRleE5vcm1hbHMgOiB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIGdlb21ldHJ5IGZvciBhIGdpdmVuIHRpbGUuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZVxuICoge0BsaW5rIE1hcHplblRlcnJhcml1bVRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhlIHJlc3VsdCBpbmNsdWRlcyB0ZXJyYWluXG4gKiBkYXRhIGFuZCBpbmRpY2F0ZXMgdGhhdCBhbGwgY2hpbGQgdGlsZXMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VGVycmFpbkRhdGE+fHVuZGVmaW5lZH0gQSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdGVkIGdlb21ldHJ5LiAgSWYgdGhpcyBtZXRob2RcbiAqICAgICAgICAgIHJldHVybnMgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBwcm9taXNlLCBpdCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgdG9vIG1hbnkgcmVxdWVzdHMgYXJlIGFscmVhZHlcbiAqICAgICAgICAgIHBlbmRpbmcgYW5kIHRoZSByZXF1ZXN0IHdpbGwgYmUgcmV0cmllZCBsYXRlci5cbiAqL1xuTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5yZXF1ZXN0VGlsZUdlb21ldHJ5ID0gZnVuY3Rpb24oeCwgeSwgbGV2ZWwsIHJlcXVlc3QpIHtcbiAgICB2YXIgdXJsID0gdGhpcy5fdXJsK2xldmVsKycvJyt4KycvJyt5KycucG5nJztcblxuICAgIHZhciBwcm94eSA9IHRoaXMuX3Byb3h5O1xuICAgIGlmIChkZWZpbmVkKHByb3h5KSkge1xuICAgICAgICB1cmwgPSBwcm94eS5nZXRVUkwodXJsKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3RlcnJhaW5Qcm9taXNlc1t1cmxdO1xuXG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBsb2FkSW1hZ2UodXJsLCB0cnVlLCByZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5fdGVycmFpblByb21pc2VzW3VybF0gPSBwcm9taXNlO1xuICAgIH1cblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGVpZ2h0bWFwVGVycmFpbkRhdGEoe1xuICAgICAgICAgICAgYnVmZmVyIDogZ2V0SW1hZ2VQaXhlbHMoaW1hZ2UsIHRoYXQuX2hlaWdodG1hcFdpZHRoLCB0aGF0Ll9oZWlnaHRtYXBXaWR0aCksXG4gICAgICAgICAgICB3aWR0aCA6IHRoYXQuX2hlaWdodG1hcFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0IDogdGhhdC5faGVpZ2h0bWFwV2lkdGgsXG4gICAgICAgICAgICBjaGlsZFRpbGVNYXNrIDogbGV2ZWwgPCAxNiA/IDAgOiAxNSxcbiAgICAgICAgICAgIHN0cnVjdHVyZSA6IHRoYXQuX3RlcnJhaW5EYXRhU3RydWN0dXJlXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXhpbXVtIGdlb21ldHJpYyBlcnJvciBhbGxvd2VkIGluIGEgdGlsZSBhdCBhIGdpdmVuIGxldmVsLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgdGlsZSBsZXZlbCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBtYXhpbXVtIGdlb21ldHJpYyBlcnJvci5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBtYXhpbXVtIGdlb21ldHJpYyBlcnJvci5cbiAqL1xuTWFwemVuVGVycmFyaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5nZXRMZXZlbE1heGltdW1HZW9tZXRyaWNFcnJvciA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciAvICgxIDw8IGxldmVsKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGRhdGEgZm9yIGEgdGlsZSBpcyBhdmFpbGFibGUgdG8gYmUgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBsZXZlbCBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBVbmRlZmluZWQgaWYgbm90IHN1cHBvcnRlZCwgb3RoZXJ3aXNlIHRydWUgb3IgZmFsc2UuXG4gKi9cbk1hcHplblRlcnJhcml1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZURhdGFBdmFpbGFibGUgPSBmdW5jdGlvbih4LCB5LCBsZXZlbCkge1xuICAgIHJldHVybiBsZXZlbCA8IDE2ID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbn07XG4iXX0=